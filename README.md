# GraphProcessorAPI

Основная идея: Нахождение кратчайших путей от одной стартовой вершины до всех остальных в взвешенном графе с неотрицательными весами рёбер.

Как работает (жадный алгоритм):

Присвоить начальной вершине расстояние 0, а всем остальным — бесконечность.

Поместить все вершины в приоритетную очередь (Min-Heap) по текущему расстоянию.

Пока очередь не пуста:

Извлечь вершину u с минимальным текущим расстоянием.

Для каждого соседа v вершины u:

Вычислить новое расстояние: расстояние_до_u + вес_ребра(u, v).

Если это расстояние меньше текущего известного расстояния до v, то обновить расстояние до v и запомнить u как предшественника v (для восстановления пути).

Повторять, пока не будут обработаны все вершины.

Ключевые свойства:

Работает только с неотрицательными весами рёбер. Отрицательные веса нарушают его логику.

Гарантированно находит оптимальные кратчайшие пути.

Сложность зависит от реализации структуры данных:

С массивом: O(V² + E) — хорошо для плотных графов.

С бинарной кучей (приоритетной очередью): O((V + E) log V) — лучше для разреженных графов.

С более продвинутыми кучами (Фибоначчи) можно улучшить до O(E + V log V).

Где применяется:

Маршрутизация в сетях (протоколы типа OSPF, IS-IS).

Построение карт и навигация (поиск кратчайшего пути по времени или расстоянию).

Моделирование потоков.

Как основа для более сложных алгоритмов (например, A* с эвристикой).
    1. Разделить на 2 отдельных компонента EdgesInputField и VertexInputField
    2. Реализовать операции (add del upd) в структуре графа, синхронизировав DataSet с
    объектом
    (Возможно изменить глобальную переменную distanceJSONObject на Map(хештаблицу),
    во избежания лишних вычислений при регенерации и увеличении скорости вставки/удаления)
    3. Начать думать об архитектуре SSR. Внедрить Nuxt.js

